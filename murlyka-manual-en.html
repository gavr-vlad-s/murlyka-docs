<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="generator" content="ReText 6.0.2">
<title>murlyka-manual-en</title>
</head>
<body>
<h1>Introduction</h1>
<p>To build projects written on C and C++, various build system are used. The most famous build systems are CMake, GNU Make, Scons, Shake, and the system used to build the Boost libraries. Consider each of these build system.  </p>
<p>System GNU Make takes a Makefile describing the build script of the project. Writing this script manually is not very convenient, if there are a lot of source files. The advantage of this system is that this system works 
both under Linux, and under Windows.</p>
<p>Systems SCons and CMake are wrappers over Make utility and generate input files for Make. System SCons is written in language Python 2.7, and has installing problem under Windows 7. There are no installing problems under Linux.
The inability to work under Windows is disadvantage of this system. The Makefile generated by CMake system, are complicated and contains absolute paths to source files and to compiler. By default, CMake uses C++ compiler,
which is standard for an operating system. Standard C++ compiler for Linux is g++ (a compiler from GCC collection). Standard C++ compiler for Windows is a compiler from Microsoft Visual Studio. However, Visual Studio compiler
does not fully support recent standards of C++ language, unlike the compiler of the GCC collection. Hence, it is better to use g++ under Windows. But, under Windows, in order for CMake used g++ and the needed keys of g++, you need to write a 
long chain of command-line arguments. As for Linux, then, in addition to the compiler from collection GCC can be installed, for example, compilers of a set of Clang. Under Linux, in order for CMake used clang, you need to write a 
long chain of command-line arguments. The build system for the Boost libraries is not recommended by an author of one of Boost library, because it is difficult to use this build system.  </p>
<p>The build system Shake is written in Haskell, and requires installed system Haskell Stack. But Haskell Stack does not work under Linux. The purpose of the system Haskell Stack is to write Makefiles as programs in Haskell, then to compile 
them by Haskell compiler, and to run resulting program. Resulting program will build the needed project. To use in C++ projects, is is disadvatage. Therefore, we need a more simple build system. It is the goal of the project Murlyka.  </p>
<h1>Input file format</h1>
<p>Input file consists of an arbitrary sequence the following commands (this sequence can be empty):</p>
<ul>
<li>
<p><em>project</em>(project_name main_file)</p>
</li>
<li>
<p><em>compiler</em>(compiler_name)</p>
</li>
<li>
<p><em>compiler_flags</em>(compiler_flags)</p>
</li>
<li>
<p><em>linker</em>(linker_name)</p>
</li>
<li>
<p><em>linker_flags</em>(linker_flags)</p>
</li>
<li>
<p><em>source_dir</em>(directory_with_source_files)</p>
</li>
<li>
<p><em>source_exts</em>(source_files_extensions)</p>
</li>
<li>
<p><em>build_dir</em>(directory_for_object_files_and_for_program)</p>
</li>
<li>
<p><em>include_dirs</em>(list_of_directories_for_header_files)</p>
</li>
<li>
<p><em>makefile_name</em>(name_for_Makefile)</p>
</li>
<li>
<p><em>libraries</em>(list_of_linked_libraries)</p>
</li>
<li>
<p><em>library_dirs</em>(directory_lst_to_search_libraries)</p>
</li>
</ul>
<p>Command <em>project</em> specifies the project name and the name of the main file (i.e. the name of the file containing function 'main'). The name of the main file is optional. The default name of the main file is the project name with prepended
extension cpp. If command <em>project</em> is not specified, then the name of the main file is 'main.cpp' and the project name is 'main'.<br>
Command <em>compiler</em> specifies a used compiler name. The default compiler name is 'g++'.<br>
Command <em>compiler_flags</em> specifies the compiler flags. The default compiler flags are '-O3 -Wall -std=c++14'.<br>
Command <em>linker</em> defines the linker name. The default linker name is the compiler name.<br>
Command <em>linker_flags</em> specifies the linker flags. The default flags is '-s'.<br>
Command <em>source_dir</em> specifies the directory with source code (files with extensions cpp, c++, cxx). The default directory is the current directory.<br>
Command <em>source_exts</em> specifies source files extensions (fextensions cpp, c++, cxx, and so on, except header files extensions).<br>
Command <em>build_dir</em> specifies a directory with object files and with an executable file. If this command is not specified, the object files and an executable file will be in the root directory of the project.<br>
Command <em>include_dirs</em> specifies the location of header files for external libraries.<br>
Command <em>makefile_name</em> specifies the name of the generated Makefile. The default name of Makefile is Makefile.<br>
Command <em>libraries</em> specifies a quoted list of names linked libraries, separated by whitespace chars (i.e. spaces and tabulations). Name format is as follows: you should not include the prefix lib and the suffix .a.<br>
Command <em>library_dirs</em> specifies a quoted list of paths for external libraries search.  </p>
<p>Here <em>project_name</em>, <em>name_for_Makefile</em>, <em>compiler_name</em>, <em>linker_name</em> are identifiers. All other arguments are string literals. Here an identifier is any non-empty sequence of Latin letters, decimal digits, characters '+' and '-', 
underscore and dot; string literal is any (including empty) sequence of characters enclosed in double quotes. If in a string literal you need to specify a double quote, it should be doubled. <br>
A string literal that is the value of the argument of the command <em>source_exts</em> is a list of source code files extensions, delimited by whitespace characters. Extensions must be specified without begin point.  </p>
<p>The argument of the command <em>include_dirs</em> contains a list separated by semicolons paths to directories containing header files for external libraries.</p>
<p>The argument of the command <em>library_dirs</em> contains a list separated by semicolons paths to directories containing external libraries.</p>
<h1>Examples</h1>
<p>Let us give examples of the program Murlyka using.</p>
<h2>Example 1.</h2>
<p>Let 'simple01' be a project with the following structure:</p>
<pre><code>simple01  
    func1.cpp  
    func1.h  
    func2.cpp  
    func2.h  
    simple01.cpp  
    build
</code></pre>
<p>Suppose that the main file is the file 'simple01.cpp", and the build directory is the directory 'build'. If we put a file (for example, a file with the name 'mkdescr.txt') in the project root directory, and this file has the following
contents</p>
<blockquote>
<p>project(simple01)<br>
compiler(g++)<br>
linker(g++)<br>
source_exts("cpp")<br>
build_dir("build")  </p>
</blockquote>
<p>then after processing this file, we will get a Makefile with the following contents:</p>
<pre><code>LINKER      = g++  
LINKERFLAGS = -s  
CXX         = g++  
CXXFLAGS    = -O3 -Wall -std=c++14  
BIN         = simple01  
vpath %.o build  
OBJ         = simple01.o func2.o func1.o  
LINKOBJ     = simple01.o func2.o func1.o

.PHONY: all all-before all-after clean clean-custom

all: all-before $(BIN) all-after

clean: clean-custom   
    rm -f ./build/*.o  
    rm -f ./build/$(BIN)

.cpp.o:  
    $(CXX) -c $&lt; -o $@ $(CXXFLAGS)

$(BIN):$(OBJ)  
    $(LINKER) -o $(BIN) $(LINKOBJ) $(LINKERFLAGS)  
    mv $(BIN) $(OBJ) ./build
</code></pre>
<h2>Example 2.</h2>
<p>Let 'simple02' be a project with the following structure:</p>
<pre><code>simple02  
    build  
    include  
        func1.h  
        func2.h  
    src  
        func1.cpp  
        func2.cpp  
        simple02.cpp
</code></pre>
<p>In other words, files with the file extension .h located in the directory 'include', and the files with the extension .cpp in the directory 'src'.
Suppose that the main file is the file 'simple01.cpp", and the build directory is the directory 'build'. If we put a file (for example, a file with the name 'mkdescr.txt') in the project root directory, and this file has the following
contents</p>
<blockquote>
<p>project(simple02)<br>
compiler(g++)<br>
linker(g++)<br>
source_exts("cpp")<br>
source_dir("src")<br>
build_dir("build")  </p>
</blockquote>
<p>then after processing this file, we will get a Makefile with the following contents:</p>
<pre><code>LINKER           = g++  
LINKERFLAGS      = -s  
COMPILER         = g++  
COMPILERFLAGS    = -O3 -Wall -std=c++14  
BIN              = simple02  
vpath %.cpp src  
vpath %.o build  
OBJ              = simple02.o func2.o func1.o  
LINKOBJ          = build/simple02.o build/func2.o build/func1.o

.PHONY: all all-before all-after clean clean-custom

all: all-before $(BIN) all-after

clean: clean-custom  
    rm -f ./build/*.o  
    rm -f ./build/$(BIN)

.cpp.o:  
    $(CXX) -c $&lt; -o $@ $(CXXFLAGS)   
    mv $@ ./build

$(BIN):$(OBJ)  
    $(LINKER) -o $(BIN) $(LINKOBJ) $(LINKERFLAGS)  
    mv $(BIN) ./build
</code></pre>
<h1>Command line syntax</h1>
<p>Command line syntax for Murlyka is  </p>
<pre><code class="bash">$ murlyka option
</code></pre>

<p>or</p>
<pre><code class="bash">$ murlyka files
</code></pre>

<p>Here 'option' is either <code>--help</code>, or <code>--version</code>. First of them displays help, second of them displays version info; 'files' are processed configuration files.</p>
<h1>Building of Murlyka project</h1>
<p>To build this project, you need to install Haskell Platform. Suppose that you installed Haskell Platform; then to build the project Murlyka, you need</p>
<pre><code class="bash">$ git clone https://github.com/gavr-vlad-s/murlyka
$ cd murlyka
$ cabal configure
$ cabal build
</code></pre>

<h1>Installing Haskell</h1>
<h2>For Windows</h2>
<ol>
<li>Download installer from <a href="https://www.haskell.org/downloads">https://www.haskell.org/downloads</a>.  </li>
<li>Run downloaded installer.  </li>
</ol>
<h2>For Debian and Debian-based Linux</h2>
<p>Execute the following command:  </p>
<pre><code class="bash">$ sudo apt-get install haskell-platform
</code></pre>

<h2>For Arch Linux and for Arch-based Linux (e.g., Manjaro Linux)</h2>
<p>Execute the following command:  </p>
<pre><code class="bash">$ sudo pacman -S ghc cabal-install haskell-haddock-api haskell-haddock-library happy alex
</code></pre>
</body>
</html>
